# "Front" 프로젝트 상세 분석 보고서 (v4)

---

## 1. 개요 (Executive Summary)

-   **프로젝트명**: 대한민국 공공체육시설 정보 제공 및 현황 분석 웹 애플리케이션 (K-Sport Hub)
-   **수행 기간**: `2025-12-17` ~ `2026-01-21`
-   **참여 인력**: 
    -   - 기획: 전국 공공체육시설 통합 플랫폼
    -   - 프론트엔드 개발: 석동찬
    -   - 데이터베이스 관리 및 백엔드 개발: 박진하
    -   - UI/UX 디자인: 석동찬
-   **프로젝트 목적 및 목표**:
    -   **목적**: 전국에 분산된 공공체육시설 데이터를 한곳에 모아 사용자에게 직관적이고 유용한 검색 및 분석 환경을 제공하는 것을 목적으로 합니다.
    -   **목표**: Spring Boot 기반의 백엔드 API와 연동하여, 사용자가 원하는 체육시설을 쉽고 빠르게 찾고 데이터 기반의 인사이트를 얻을 수 있는 고품질의 웹 서비스를 구축하는 것을 목표로 합니다.
-   **핵심 성과 요약**:
    -   Next.js와 TypeScript 기반의 최신 기술 스택을 활용한 웹 애플리케이션 개발.
    -   지역, 시설 종류, 키워드를 포함하는 다각적인 체육시설 검색 및 필터링 기능 구현.
    -   지도와 차트를 활용한 데이터 시각화 대시보드 구축 (지역별 분포, 시설 종류별 비율 등).
    -   AI(Gemini)를 활용한 데이터 분석 및 요약 리포트 기능 프로토타입 구현.
    -   로딩 스켈레톤 UI 적용을 통한 사용자 경험(UX) 개선.

## 2. 기획 및 분석 (Planning & Analysis)

-   **시장/사용자 분석**:
    -   국민들의 건강 증진 및 여가 활동에 대한 관심이 높아짐에 따라 공공체육시설의 이용 수요가 꾸준히 증가하고 있습니다. 하지만, 관련 정보가 여러 기관에 흩어져 있어 사용자가 원하는 정보를 얻기 어려운 상황입니다.
    -   사용자들은 자신이 거주하는 지역 또는 관심 지역의 체육시설 정보를 손쉽게 찾고, 시설의 상세 정보(운영 시간, 요금, 예약 가능 여부 등)를 한눈에 파악하고자 하는 명확한 요구를 가지고 있습니다.
-   **요구사항 정의**:
    -   **기능적 요구사항**:
        -   사용자 인증: 회원가입, 로그인, 로그아웃 기능.
        -   시설 검색: 지역, 종류, 이름 기반 검색 및 필터링.
        -   상세 정보 조회: 개별 시설의 주소, 연락처, 운영 정보 등 표시.
        -   리뷰: 사용자가 시설에 대한 리뷰를 작성하고 조회하는 기능.
        -   대시보드: 전국/지역별 시설 현황 데이터 시각화 (지도, 차트).

## 3-1. FE 설계 및 구현 (Design & Implementation)

-   **아키텍처 설계**:
    -   **프레임워크**: **Next.js (App Router)**를 채택하여 서버 사이드 렌더링(SSR)의 장점을 극대화하고 SEO 및 초기 로딩 성능을 확보했습니다.
    -   **데이터 통신**: Spring Boot + MySQL로 구성된 **외부 백엔드 API**로부터 데이터를 Fetch합니다. Next.js의 서버 액션(`actions.ts`)을 **BFF(Backend For Frontend)** 패턴으로 활용하여, 프론트엔드와 백엔드 API 사이의 중간 계층 역할을 수행합니다. 이를 통해 API 엔드포인트나 키를 클라이언트에 노출하지 않고 안전하게 데이터를 주고받습니다.
    -   **언어**: **TypeScript**를 사용하여 코드의 안정성과 유지보수성을 높였습니다.
    -   **스타일링**: **Tailwind CSS**를 사용하여 빠르고 일관된 UI 개발을 추구했습니다.
-   **디자인 가이드라인**:
    -   (*참고: 별도의 디자인 시스템이나 UI 키트가 있다면 이곳에 명시하거나 관련 파일을 첨부해주세요. 예: 컬러 팔레트, 타이포그래피, 아이콘 시스템 등*)
-   **주요 기능 구현 내용**:
    -   **데이터 시각화**: `D3.js`와 `TopoJSON`을 사용하여 지도 시각화를, `Chart.js` 또는 `Recharts`를 활용하여 통계 차트를 구현했습니다.
    -   **API 연동**: `fetch` API와 서버 액션을 통해 백엔드 API의 데이터를 비동기적으로 호출하고, 이를 서버 컴포넌트나 클라이언트 컴포넌트에 전달하여 렌더링합니다.
    -   **인증**: React Context API (`AuthContext.tsx`)를 활용하여 사용자의 로그인 상태(토큰 등)를 전역적으로 관리합니다.
-   **개발 환경**:
    -   **코드 관리**: Git, GitHub
    -   **패키지 매니저**: npm
    -   **개발 언어/프레임워크**: Node.js, Next.js, TypeScript, React
    -   **배포 환경**: Vercel

## 3-2. BE 설계 및 구현 (Design & Implementation)
-    **아키텍처 설계**:
    -   **스타일**: REST API

-   **주요 기능 구현 내용**:
    -   **Controller**: MVC에서 Controller를 담당. Front에서 넘어온 요청을 처리 (CRUD). 
    -   **인증/인가**: Spring Security의 JWT인증 및 인가 사용. Google, Naver 로그인 지원.  
-   **개발 환경**:
    -   **코드 관리**: Git, GitHub
    -   **개발 언어/프레임워크**: STS4 (Spring Tool Suite with Eclipse IDE), Java, MySQL, Supabase
    -   **배포 환경**: BE server: Render, DB server: 미정

## 4. 결과 및 테스트 (Results & Testing)

-   **최종 결과물**:
    -   **URL**: `https://kdt-mini-front.vercel.app/`
-   **테스트 및 검증**:
    -   **버그 수정 내역**: 
        - AI(Gemini) 데이터 분석 토큰 제한으로 분석 버튼 생성
        - 페이지 Reload 시 검색 필터 유지

## 5-1 FE. 문제점 및 해결 방안 (Issues & Solutions)

-   **프로젝트 진행 중 발생한 주요 문제점**:
    1.  **정적 및 동적 렌더링의 판단**: BE 코드 작성에 익숙지 못하여 페이지의 렌더링을 어떻게 할 것인지에 대해 생각하지 않고 대부분의 페이지를 CSR로 구성했다. 그래서 대시보드와 같은 초기 데이터양이 많은 페이지를 열면 초기 로딩 속도가 많이 느렸다.
    2.  **클라이언트 상태 관리의 복잡성**: 현재 인증 상태는 `AuthContext`와 localStorage로 관리되어 사용자 인증이 필요한 페이지의 경우, 새로고침 시 AuthConext의 값을 불러오기 전에 페이지가 로드되어 내용이 보이지 않는 상황이 발생하였다.
-   **해결 과정 및 결과**:
    1.  **SSR으로 렌더링 변경**: 대시보드, 상세검색의 페이지의 초기 로딩 속도 향상을 위해 SSR + CSR로 변경했다. 로딩중인 경우는 스켈레톤 UI를 추가하여 페이지가 동작한다는 느낌을 주었다. 추가로 더 수정을 할 수 있다면 대시보드는 데이터의 수정이 빠르게 이루어지지 않으므로 ISR로 변경하여 속도 향상과 벡엔드 서버의 부하를 줄일 수 있을것이다.
    2.  **서버 상태 관리 라이브러리 도입**: 페이지 로드 시 `AuthContext`의 값 혹은 localStorage에 저장된 값을 가져오기 전에 페이지가 완전 로드되지 않도록 수정하였다. 인증 값을 Cookie에 저장하거나, Jotai같은 경량 상태 관리 라이브러리를 사용하면 로드 속도가 더 빨라질 것이다.
-   **교훈 (Lessons Learned)**:
    -   클라이언트 상태와 서버 상태를 명확히 분리하고, 각 특성에 맞는 적절한 상태 관리 도구를 사용하는 것이 애플리케이션의 복잡도를 제어하는 핵심임을 알게 되었다.

## 5-2 BE. 문제점 및 해결 방안 (Issues & Solutions)

-   **해결된 문제점**:
    1.  **쿠키와 CORS**: 인증 성공시 발행되는 JWT토큰을 쿠키에 담아 FE에 전송하려했으나 http 환경에서는 외부주소에서 쿠키를 확인하기가 어려웠음. 토큰을 쿠키에 담아 보내는 대신, 토큰을 헤더로 전송하여 FE에서 localStorage에 저장하는 방법으로 해결. 
    2.  **인증 및 인가 예외처리**: 인증 및 인가 실패시 응답에 200 OK와 함께 텅빈 JSON이나 로그인페이지의 HTML소스를 넘기는 일이 발생했었음. 필터에서 예외 발생시 null을 return하는 경우를 모두 throw exception으로 변경하고, SecurityFilterChain에 exceptioHandling을 추가해줌으로 인증 및 인가 실패 예외처리를 해결. 
    3. **FE에 전달해주는 데이터의 타입**: 일부 API의 리턴타입이 배열의 배열인 경우가 있어서 FE에서 데이터를 읽어오는데 어려움이 있었음. 이후 작성한 API들은 오브젝트의 배열을 전달하여 FE에서 읽어오기 편하도록 하였다.
-   **그 외 교훈 (Lessons Learned)**:
    1. Oauth2 인증 절차에 대해 명확히 이해하게 되었다.
    2. **FE와의 소통**: 프로젝트 진행의 전체적인 흐름을 이해하게 되었다. FE와 BE간 다음과 같은 소통이 중요하다고 생각되었다.
    어떤 페이지를 만들 것인가? 
    -> 프론트에서는 페이지와 컴포넌트들을 어떻게 구성할 것인가?
    ->각 컴포넌트당 필요한 데이터들은 무엇인가? 
    ->프론트는 그 데이터들을 백에서 어떻게 전달받고 싶은가?
        (변수명, API URI, 응답형태, 데이터의 가공여부 등에 대한 논의가 필요)
    ->기능구현 및 테스트
        (한 컴포넌트, 혹은 한 페이지 완성 후 테스트)
    ->테스트 후 논의과정을 거쳐 수정 작업

## 6. 참고 자료 및 부록 (References & Appendix)

-   **관련 문서**: `https://docs.google.com/presentation/d/16U15lKPDMJlbXTrmKklQ2216CRzsRaMmtHInWB6ZNjo/edit?slide=id.p1#slide=id.p1`
-   **소스 코드 저장소**: `https://github.com/zodib0123/kdt_mini_front`